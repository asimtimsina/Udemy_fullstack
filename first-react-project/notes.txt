595. The Basics of JSX

JSX is a syntax extension to JavaScript.
It is similar to a template language, but it has full power of JavaScript. 
JSX gets compiled to React.createElement() calls which return plain JavaScript objects called ‚ÄúReact elements‚Äù. Babel compiles JSX down to React.createElement() calls.

It allows us to write markup that looks like HTML directly inside of our HTML.
It's not legal JS on it's own so it must be transpiled into JS.

Babel behind the scenes will take the JSX and convert it into React.createElement() calls.




596. Basic React App Structure

App is the root component of our application. Top level component.
App component is the parent of all other components.


597. Our First React Component

function Greeter() {
  return <h1>HELLO! </h1>;
}

export default function App() {
  return (
    <div className="App">
      <h1>Hello CodeSandbox!!</h1>
      <h2>Start editing to see some magic happen!</h2>
      <input type="text" />
      <Greeter/> 
      {/* Call the function */}
    </div>
  );
}


598. Importing and Exporting Components
One component per file.
We can import and export components from one file to another.

Use ES6 modules to import and export components.
import Greeter from "./Greeter.js";

But we first need to export something that can be imported

export 
default

export default function Greeter() {
  return <h1>HELLO! </h1>;
}

Can also do

 function Greeter() {
  return <h1>HELLO! </h1>;
}
export default Greeter;


Can also export multiple things from a file
export {dog, cat};
But must import them like this
import {dog, cat} from "./animals.js";


function add(x, y) {
  return x + y;
}
function multiple(x, y) {
  return x * y;
}
export { add, multiple };


599. The Rules of JSX

You must explicityly close all tags.  like <br> must be <br />.
You can only return a single element from a component.  You can't return two sibling elements.  You can wrap them in a div or a fragment.

export default function LoginForm() {
  return (
    <form>
      <label> ID </label>
      <input type="text " />
      <label> password </label>
      <input type="password " />
      <button> Submit </button>
    </form>
  );
}



600. React Fragments

Can use react fragments to wrap multiple elements.
<> </> or <React.Fragment> </React.Fragment>

export default function LoginForm() {
  return (
    <>
      <label> ID </label>
      <input type="text " />
      <label> password </label>
      <input type="password " />
      <button> Submit </button>
    </>
  );
}

601. Evaluating JS Expressions in JSX

We can evaluate JS expressions inside of JSX using curly braces.
{}
We can't use if statements or for loops inside of JSX.  We can use ternary operators.
 
const name = 'Bhusiya';
return <p> {name} says WOOOF </p>; -> Bhusiya says WOOOF


602. Creating. a Die Component

export default function Die() {
  const roll = Math.floor(Math.random() * 6 + 1);
  return <h1> Die Roll: {roll} </h1>;
}



603. Component Decomposition

import Die from "./Die";

export default function DiceHand() {
  return (
    <div>
      <Die />
      <Die />
      <Die />
    </div>
  );
}


604. Styling Components

Use className instead of class. 
className is a reserved word in JS.
Create a seperate css file and import it into the component file.
import "./Die.css";


605. Random PokeCard Exercise

import "./RandomPokemon.css";

export default function Pokemon() {
  const rand = Math.floor(Math.random() * 150 + 1);
  const url = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${rand}.png`;

  return (
    <div className="RandomPokemon">
      <h1 className="h1"> Random #{rand} </h1>
      <img className="pokeImg" alt="..." src={url} />
    </div>
  );
}



607. Creating React Apps With Vite

Vite is a build tool for modern web projects.

npm create vite@latest
Follow commands and create a react app.
install all dependencies using npm install
use npm run dev to start the server.



608. A Note About Create React App

Similar to vite but it's more mature and has more features.
It's a bit more complicated to use.


609. A Tour of A Vite App

New components are created in the src folder.
.jsx files are used instead of .js files.
index.html is the entry point of the app.
index.jsx is the entry point of the app.
index.html has a div with id="app" which is the root div of the app.



610. Introducing Props

Props are a way to pass data from a parent component to a child component.
Props are immutable.  They can't be changed by the child component.
Props are passed as attributes to the child component.



export default function Greeter(props) {
    console.log(props)
    return <h1>HELLO {props.person}!! </h1>
}

props is an object that contains all the props passed to the component.
props.person is the value of the person prop passed to the component.
can also destructure the props object

export default function Greeter({person}) {
    return <h1>HELLO {person}!! </h1>
}



611. Non-String Props
Use {} to pass non-string props.


612. Setting Default Prop Values

export default function Die({ numSides =6 }) {
    const roll = Math.floor(Math.random() * numSides + 1);
    return <p>{numSides} sided die roll: {roll}</p>
}


613. Passing Arrays and Objects


<ListPicker values={['Asim', 'Nick', 'Bish']} />
<ListPicker values={{a:1,b:2}} /> 
First {} is for JS expression and second {} is for object literal.

export default function ListPicker({ values }) {
    const randIndex = Math.floor(Math.random() * values.length);
    console.log(randIndex)
    return (
        <div>
            <p>Random value from the list is {values[randIndex]} </p>
        </div>
    )



614. React Conditionals

multiple way to use conditionals in JSX.

Use ternary operator to conditionally render JSX.
{condition ? <p>True</p> : <p>False</p>}

<h2>{num1 === num2 ? 'You Win!!!' : 'You Lose!!!'}</h2>
{num1 === num2 ? <h2>You Win</h2> : null}
{num1 === num2 && <h2>You Win</h2>}


615. The React Developer Tools
https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi


616. Adding Dynamic Component Styles

const styles = { color: num1 === num2 ? 'green' : 'red' }
    return (
        <div className="DoubleDice" style={styles}>
            {num1 === num2 ? <h2>You Win</h2> : null}
            <p>Num1: {num1}</p>
            <p>Num2: {num2}</p>
        </div>
    )

<Heading color='teal' text='Hi Everyone' />
export default function Heading({ color = 'olive', text }) {
    return (
        <h1 style={{ color: color }}>{text}</h1>
    )
}


617. Rendering Arrays With Map

export default function ColorList({ color }) {
    const lis = color.map((col) => <li>{col}</li>)
    return (
        <div>
            <p>Color List</p>
            <p>{lis}</p>
        </div>
    )

}

Common way to render arrays in JSX is to use map method.
export default function ColorList({ color }) {
    // const lis =color.map((col) => ( <li>{col}</li>)) 
    return (
        <div>
            <p>Color List</p>
            <ul>
                {color.map((col) => (
                    <li style={{ color: col }}>{col}</li>
                ))}
            </ul>
        </div>
    )

}

618. Slot Machine Exercise

export default function Slots() {

    const logos = ['üçí', 'üçå'];
    const var1 = logos[Math.floor(Math.random() * logos.length)];
    const var2 = logos[Math.floor(Math.random() * logos.length)];
    const var3 = logos[Math.floor(Math.random() * logos.length)];

    // console.log(var1, var2, var3);
    const isWinner = var1 === var2 && var1 === var3;
    const styles = { color: isWinner ? 'green' : 'red' }
    return (
        <>
            <h1>{var1} {var2} {var3}</h1>
            <h2 style={styles}> {isWinner ? 'You Win' : 'You Lose'}</h2>
            <h3>{isWinner ? 'Congrats' : null}</h3>
        </>
    )
}


619. Creating A Shopping List Component

export default function ShoppingList({ lists }) {
    return (
        <>
            <ul>
                {lists.map((item) => (<li style={{
                    color: item.picked ? 'grey' : 'red',
                    textDecoration: item.picked ? "line-through" : 'none'
                }}>{item.name} - {item.quantity}</li>))}
            </ul>
        </>
    )

}



620. The Key Prop
Missing key prop for list items.
React uses key prop to keep track of list items. Key prop should be unique for each list item.

{lists.map((item) => (<li key={item.id} 
...
...



621. The Shopping List Item Component

Move to a separate component.

function ShoppingListItem({ name, quantity, picked }) {
    const styles = {
        color: picked ? 'grey' : 'red',
        textDecoration: picked ? "line-through" : 'none'
    }
    return (
        <li style={styles}> {name} - {quantity}</li>

    )
}
export default ShoppingListItem;


Can use spread operator to pass props to the component.
<ShoppingListItem key={item.id} {...item} />


622. Rental Property Exercise



624. Configuring ESLint
Add  "react/prop-types": 'off', to .eslintrc.json file to disable prop-types warning.


625. PropTypes Library Crash Course
https://github.com/facebook/prop-types
ShoppingListItem.propTypes = {
    name: PropTypes.string,
    quantity: PropTypes.number,
    picked: PropTypes.bool
}


626. Intro to React Events

use OnClick event to handle click events.
OnClick supports a function that will be called when the event occurs.



function handleClick() {
    console.log('Clicked')
}

export default function Clicker() {
    return (
        <div>
            <p>Click Me</p>
            <button onClick={handleClick}>Click {count}</button>
        </div>
    )
}


627. Non-Click Events
Can use any event with React. Must use camelCase for event names.

onMouseOver
onMouseOut
onFocus
onBlur
onChange
onSubmit
onKeyDown
onKeyUp
onKeyPress



628. Working With The Event Object
Event object is passed to the event handler function.

For Forms can use onSubmit to handle form submission.

function handleFormSubmit(e) {
    console.log('Form Submitted')
    e.preventDefault();
}

export default function Forms() {
    return (
        <form onSubmit={handleFormSubmit}>
            <button>Submit</button>
        </form>

    )
}


629. Clicker Exercise

<button onClick={() => alert(message)} > {buttonText}</button >




630. Introducing State
State is data that is managed inside a component. State can change over time.
If the data needs to change over time, it is state.



631. Working With The useState() Hook

useState is a function that returns an array with two elements.

const [count, setCount] = useState(0);
count is the current value of the state.
setCount is a function that is used to update the state.
0 -> initial value of the state.


must import useState from react.
useSetNum to update the state.
setNum(num + 1) to update the state.

import { useState } from "react";

export default function Counter() {
    const [num, setNum] = useState(5);
    const handleClick = () => {
        setNum(num + 1)
        console.log(num)
    }
    return (
        <>
            <p>The count is: {num} </p>
            <button onClick={handleClick}>Increment </button>
        </>
    )

}


632. Creating a Toggler Component

isHappy is set to True by default.
setIsHappy is a function that is used to update the state.
Toggle is a function that is used to update the state.

import { useState } from "react"

export default function Toggler() {
    const [isHappy, setIsHappy] = useState(true);
    const Toggle = () => setIsHappy(!isHappy)
    return (
        <h1 onClick={Toggle}>{isHappy ? 'üòä' : "üò≠"}</h1>
    )
}


633. Multiple Pieces of State In A Component
We can have multiple pieces of state in a component.

import { useState } from "react"

export default function Toggler() {
    const [isHappy, setIsHappy] = useState(true);
    const Toggle = () => setIsHappy(!isHappy)

    const [count, setCount] = useState(0);
    const increment = () => setCount(count + 1)
    return (
        <>
            <h1 onClick={Toggle}>{isHappy ? 'üòä' : "üò≠"}</h1>
            <p>{count}</p>
            <button onClick={increment}>+</button>
        </>
    )
}



634. useState() and Rendering

useState(initialState) only sets the initial state when the component is rendered for the first time.
Eventhough the whole component is rendered everytime the state is updated, the useState() function is not called again.



637. Setting State With An Updater Function
Use updater function to update the state based on the previous state.
Only necessary when the new state depends on the previous state.

const handleClickThree = () => {
    setNum(c => c + 1)
    setNum(c => c + 1)
    setNum(c => c + 1)
}



638. State Initializer Functions

useState() can also take a function as an argument.
This function will be called only once when the component is rendered for the first time.

IMP: The function will be called everytime the set function is called. But the result is only used for the first time.

const [bord, setBoard] = useState(generateGameBoard); -> generateGameBoard only runs for the first time
const [bord, setBoard] = useState(generateGameBoard()); -> generateGameBoard runs everytime setBoard is called. But the value won't be used.



639. When Does React Re-Render?
Set function itself doesn't cause a re-render.
React re-renders the component when the state changes.
React compares the previous state with the new state and only re-renders the component if the state has changed.