391. Connecting Mongoose to Mongo

npm i moongose


393. Our First Mongoose Model

model is a representation of a collection in the database
must define the schema for the model
schema defines the structure of the document, default values, validators, etc.

const movieSchema = new mongoose.Schema({
    title: String,
    year: Number,
    score: Number,
    rating: String
});

take this schema and compile it into a model

const Movie = mongoose.model('Movie', movieSchema); 
// Movie is the name of the model 
// creates a collection called movies

Add a movie instance to the database

const amadeus = new Movie({title: 'Amadeus', year: 1986, score: 9.2, rating: 'R'});
amadeus.save(); // saves to the database


const Herapheri = new Movie({ title: 'Hera pheri', year: 2001, score: 9, rating: 'R' })
const Herapheri_2 = new Movie({ title: 'Hera pheri 2', year: 2010, score: 7, rating: 'R' })

Herapheri.save(); // save to the database


Herapheri_2.save() // save to the database

Herapheri_2.score = 2.5; // update the score
Herapheri_2.save(); // save the updated score


394. Insert Many

Movie.insertMany([
    {title: 'Amelie', year: 2001, score: 8.3, rating: 'R'},
    {title: 'Alien', year: 1979, score: 8.1, rating: 'R'},
    {title: 'The Iron Giant', year: 1999, score: 7.5, rating: 'PG'},
    {title: 'Stand By Me', year: 1986, score: 8.6, rating: 'R'},
    {title: 'Moonrise Kingdom', year: 2012, score: 7.3, rating: 'PG-13'}
])
.then(data => {
    console.log('It worked!');
    console.log(data);
})


395. Finding With Mongoose

Finding takes time so it returns a promise
can use .then() or async/await

.find()
.findOne()
.findById()


Movie.find(); -> returns the object
Movie.find().then(data => console.log(data)); -> returns all movies

Movie.find({year : {$gt:2010}}).then(data => console.log(data)); -> returns movies with year greater than 2010
Movie.findOne({year : {$gt:2010}}).then(data => console.log(data)); -> returns movies with year greater than 2010

Movie.findById('64a061c24239a7296e679a77').then(data => console.log(data));


396. Updating With Mongoose

.updateOne()
.updateMany()
.findOneAndUpdate()
.findByIdAndUpdate()

 Movie.updateOne({title:'Amelie'},{year:1984}).then(res => console.log(res))

 Movie.updateMany({ title: { $in: ['Amadeus', 'Stand by me'] } }, { score: 10 })
    .then(res => console.log(res))

Movie.findOneAndUpdate({title:'The Iron Giant'},{score:7.8}, {new:true}).then(res => console.log(res))
// new:true returns the updated object // new:false returns the old object (by default it is false)


397. Deleting With Mongoose!

.deleteOne()
.deleteMany()
.findOneAndDelete()
.findByIdAndDelete()

 Movie.deleteOne({title: "Amelie"}).then(res => console.log(res)) // deletes the document and doesn't return it
Movie.deleteMany({year: {$gte : 1990}}).then(res=> console.log(res)); // deletes the document and doesn't return it

Movie.findOneAndDelete({title:'Alien'}).then(res=> console.log(res)); // returns the deleted object



398. Mongoose Schema Validations

const productSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    price: {
        type: Number
    }
})


const car = new Product({ name: 'Toyota', price: 59999, color: 'red' });

{
    _id: ObjectId("64a0a9c75aecb346c035a03a"),
    name: 'Toyota',
    price: 59999,
    __v: 0
  }

It will not include the color property in the object



399. Additional Schema Constraints

All Schema options

required: boolean or function, if true adds a required validator for this property
default: Any or function, sets a default value for the path. If the value is a function, the return value of the function is used as the default.
select: boolean, specifies default projections for queries
validate: function, adds a validator function for this property
get: function, defines a custom getter for this property using Object.defineProperty().
set: function, defines a custom setter for this property using Object.defineProperty().
alias: string, mongoose >= 4.10.0 only. Defines a virtual with the given name that gets/sets this path.
immutable: boolean, mongoose >= 4.10.0 only. If true, Mongoose prevents you from changing the value of this path once the document is created.
transform: function, mongoose >= 4.10.0 only. Applies a transform function to the resulting document before returning the result from the db
min: number, sets a minimum number validator
max: number, sets a maximum number validator


400. Validating Mongoose Updates

Validation doesn't run on update() by default, only on save() and create()
to run validators on update(), set the runValidators option for update() to true

Product.findOneAndUpdate({ name: 'Tire Pump' }, { price: -50 }, { new: true })
    .then(res => {
        console.log('It worked')
        console.log(res)
    })
    .catch(err => {
        console.log('Error')
        console.log(err)
    })

Price will be set to -50 even though it is less than 0


Product.findOneAndUpdate({ name: 'Tire Pump' }, { price: -50 }, { new: true, runValidators: true })
    .then(res => {
        console.log('It worked')
        console.log(res)
    })
    .catch(err => {
        console.log('Error')
        console.log(err)
    })

Error: Validation failed: price: Path `price` (-50) is less than minimum allowed value (0)


401. Mongoose Validation Errors

Can add custom error messages
min: [0, 'Price must be positive!']


Product.findOneAndUpdate({ name: 'Tire Pump' }, { price: -50 }, { new: true, runValidators: true })
    .then(res => {
        console.log('It worked')
        console.log(res)
    })
    .catch(err => {
        console.log('Error')
        console.log(err)
    })
Error: Validation failed: price: Price Must be Postive Num



402. Model Instance Methods

model instance methods are methods that we can call on an instance of the model

productSchema.methods.toggleOnSale = function () {
    console.log("Changing the OnSale ")
    this.onSale = !this.onSale;
    this.save();
}

const Product = mongoose.model('Product', productSchema);


const findProduct = async () => {
    const foundProduct = await Product.findOne({ name: 'Bike Helmet' });
    console.log(foundProduct);
    await foundProduct.toggleOnSale();
    console.log(foundProduct);
}

findProduct();

{
  _id: new ObjectId("64a0aac5109d1564c1c86917"),
  name: 'Bike Helmet',
  price: 29.99,
  onSale: false,
  __v: 0
}
Changing the OnSale
{
  _id: new ObjectId("64a0aac5109d1564c1c86917"),
  name: 'Bike Helmet',
  price: 29.99,
  onSale: true,
  __v: 0
}


403. Adding Model Static Methods

static methods are methods that we can call directly from the model itself


productSchema.statics.changePrice = function () {
    console.log("Here inside fireSale funcion")
    return this.updateMany({}, { onSale: true, price: 0 });
}

fireSale()
    .then(res => {
        console.log('It worked')
        console.log(res)
    })


404. Mongoose Virtuals

Virtuals are additional fields for a given model
Their values can be set manually or automatically with defined functionality
Virtual properties do NOT get persisted in the database


const personSchema = mongoose.Schema({
    firstName: String,
    lastName: String
})

personSchema.virtual('fullName').get(function () {
    return `${this.firstName} ${this.lastName}`;
})

const Person = mongoose.model('Person', personSchema);

const newPerson = new Person({ firstName: 'Nischal', lastName: 'Timsina' })
newPerson.save()
    .then(res => {
        console.log(res)
    })
    .catch(err => {
        console.log(err)
    })

console.log(newPerson.fullName) // Nischal Timsina